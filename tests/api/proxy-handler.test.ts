import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { Request, Response } from 'express';
import { ProxyHandler } from '../../src/api/proxy-handler';
import { OpenAIClient } from '../../src/services/openai-client';
import { ToolService } from '../../src/services/tool-service';
import { ConversationLogger } from '../../src/services/conversation-logger';

// Mock the services\njest.mock('../../src/services/openai-client');\njest.mock('../../src/services/tool-service');\njest.mock('../../src/services/conversation-logger');\n\nconst MockedOpenAIClient = OpenAIClient as jest.MockedClass<typeof OpenAIClient>;\nconst MockedToolService = ToolService as jest.MockedClass<typeof ToolService>;\nconst MockedConversationLogger = ConversationLogger as jest.MockedClass<typeof ConversationLogger>;\n\ndescribe('ProxyHandler', () => {\n  let proxyHandler: ProxyHandler;\n  let mockOpenAIClient: jest.Mocked<OpenAIClient>;\n  let mockToolService: jest.Mocked<ToolService>;\n  let mockConversationLogger: jest.Mocked<ConversationLogger>;\n  let mockReq: Partial<Request>;\n  let mockRes: Partial<Response>;\n\n  beforeEach(() => {\n    mockOpenAIClient = new MockedOpenAIClient() as jest.Mocked<OpenAIClient>;\n    mockToolService = new MockedToolService() as jest.Mocked<ToolService>;\n    mockConversationLogger = new MockedConversationLogger() as jest.Mocked<ConversationLogger>;\n\n    proxyHandler = new ProxyHandler();\n    (proxyHandler as any).openAIClient = mockOpenAIClient;\n    (proxyHandler as any).toolService = mockToolService;\n    (proxyHandler as any).conversationLogger = mockConversationLogger;\n\n    mockReq = {\n      body: {\n        model: 'gpt-4',\n        messages: [\n          { role: 'user', content: 'Hello' },\n        ],\n      },\n      headers: {},\n      apiKey: {\n        id: 1,\n        key: 'test-key',\n        name: 'Test Key',\n      },\n    };\n\n    mockRes = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn().mockReturnThis(),\n      setHeader: jest.fn().mockReturnThis(),\n      write: jest.fn().mockReturnThis(),\n      end: jest.fn().mockReturnThis(),\n    };\n\n    jest.clearAllMocks();\n  });\n\n  describe('handleChatCompletion', () => {\n    it('should return 401 when no API key provided', async () => {\n      mockReq.apiKey = undefined;\n\n      await proxyHandler.handleChatCompletion(mockReq as any, mockRes as any);\n\n      expect(mockRes.status).toHaveBeenCalledWith(401);\n      expect(mockRes.json).toHaveBeenCalledWith({ error: 'Unauthorized' });\n    });\n\n    it('should inject proxy tools and handle response', async () => {\n      const mockTools = [\n        {\n          id: 1,\n          name: 'calculator',\n          description: 'Calculate math expressions',\n          type: 'function' as const,\n          parameters: { type: 'object' },\n          implementation: 'return eval(args.expression);',\n          mcpServerCommand: null,\n          active: true,\n        },\n      ];\n\n      const mockResponse = {\n        id: 'resp-123',\n        object: 'chat.completion' as const,\n        created: Date.now(),\n        model: 'gpt-4',\n        choices: [\n          {\n            index: 0,\n            message: {\n              role: 'assistant' as const,\n              content: 'Hello! How can I help you?',\n            },\n            finish_reason: 'stop' as const,\n          },\n        ],\n        usage: {\n          prompt_tokens: 10,\n          completion_tokens: 15,\n          total_tokens: 25,\n        },\n      };\n\n      mockToolService.getToolsForApiKey.mockResolvedValue(mockTools);\n      mockToolService.convertToOpenAITools.mockReturnValue([\n        {\n          type: 'function',\n          function: {\n            name: 'calculator',\n            description: 'Calculate math expressions',\n            parameters: { type: 'object' },\n          },\n        },\n      ]);\n      mockToolService.filterProxyTools.mockReturnValue(mockResponse);\n      mockConversationLogger.startConversation.mockResolvedValue('conv-123');\n      mockConversationLogger.logRequest.mockResolvedValue();\n      mockConversationLogger.logResponse.mockResolvedValue();\n      mockConversationLogger.endConversation.mockResolvedValue();\n      mockOpenAIClient.createChatCompletion.mockResolvedValue(mockResponse);\n\n      await proxyHandler.handleChatCompletion(mockReq as any, mockRes as any);\n\n      expect(mockToolService.getToolsForApiKey).toHaveBeenCalledWith(1);\n      expect(mockToolService.convertToOpenAITools).toHaveBeenCalledWith(mockTools);\n      expect(mockOpenAIClient.createChatCompletion).toHaveBeenCalled();\n      expect(mockConversationLogger.startConversation).toHaveBeenCalled();\n      expect(mockConversationLogger.logResponse).toHaveBeenCalled();\n      expect(mockRes.json).toHaveBeenCalledWith(mockResponse);\n    });\n\n    it('should handle tool calls in responses', async () => {\n      const mockTools = [\n        {\n          id: 1,\n          name: 'calculator',\n          description: 'Calculate math expressions',\n          type: 'function' as const,\n          parameters: { type: 'object' },\n          implementation: 'return eval(args.expression);',\n          mcpServerCommand: null,\n          active: true,\n        },\n      ];\n\n      const responseWithToolCall = {\n        id: 'resp-123',\n        object: 'chat.completion' as const,\n        created: Date.now(),\n        model: 'gpt-4',\n        choices: [\n          {\n            index: 0,\n            message: {\n              role: 'assistant' as const,\n              content: null,\n              tool_calls: [\n                {\n                  id: 'call-123',\n                  type: 'function' as const,\n                  function: {\n                    name: 'calculator',\n                    arguments: '{\"expression\": \"2+2\"}',\n                  },\n                },\n              ],\n            },\n            finish_reason: 'tool_calls' as const,\n          },\n        ],\n      };\n\n      const finalResponse = {\n        ...responseWithToolCall,\n        choices: [\n          {\n            index: 0,\n            message: {\n              role: 'assistant' as const,\n              content: 'The result of 2+2 is 4.',\n            },\n            finish_reason: 'stop' as const,\n          },\n        ],\n      };\n\n      mockToolService.getToolsForApiKey.mockResolvedValue(mockTools);\n      mockToolService.convertToOpenAITools.mockReturnValue([]);\n      mockToolService.executeTool.mockResolvedValue({\n        success: true,\n        result: { result: 4 },\n      });\n      mockToolService.filterProxyTools.mockReturnValue(finalResponse);\n      mockConversationLogger.startConversation.mockResolvedValue('conv-123');\n      mockConversationLogger.logRequest.mockResolvedValue();\n      mockConversationLogger.logResponse.mockResolvedValue();\n      mockConversationLogger.endConversation.mockResolvedValue();\n      \n      // First call returns response with tool call, second call returns final response\n      mockOpenAIClient.createChatCompletion\n        .mockResolvedValueOnce(responseWithToolCall)\n        .mockResolvedValueOnce(finalResponse);\n\n      await proxyHandler.handleChatCompletion(mockReq as any, mockRes as any);\n\n      expect(mockToolService.executeTool).toHaveBeenCalledWith(\n        'calculator',\n        { expression: '2+2' },\n        1\n      );\n      expect(mockOpenAIClient.createChatCompletion).toHaveBeenCalledTimes(2);\n      expect(mockRes.json).toHaveBeenCalledWith(finalResponse);\n    });\n\n    it('should handle streaming responses', async () => {\n      mockReq.body.stream = true;\n      \n      const mockStream = {\n        on: jest.fn((event, callback) => {\n          if (event === 'data') {\n            // Simulate stream data\n            setTimeout(() => callback(Buffer.from('data: {\"choices\":[{\"delta\":{\"content\":\"Hello\"}}]}\\n\\n')), 10);\n          } else if (event === 'end') {\n            setTimeout(() => callback(), 20);\n          }\n        }),\n      };\n\n      mockToolService.getToolsForApiKey.mockResolvedValue([]);\n      mockToolService.convertToOpenAITools.mockReturnValue([]);\n      mockToolService.filterProxyTools.mockImplementation((response) => response);\n      mockConversationLogger.startConversation.mockResolvedValue('conv-123');\n      mockConversationLogger.logRequest.mockResolvedValue();\n      mockConversationLogger.endConversation.mockResolvedValue();\n      mockOpenAIClient.createChatCompletion.mockResolvedValue(mockStream as any);\n\n      await proxyHandler.handleChatCompletion(mockReq as any, mockRes as any);\n\n      expect(mockRes.setHeader).toHaveBeenCalledWith('Content-Type', 'text/event-stream');\n      expect(mockRes.setHeader).toHaveBeenCalledWith('Cache-Control', 'no-cache');\n      expect(mockRes.setHeader).toHaveBeenCalledWith('Connection', 'keep-alive');\n    });\n\n    it('should handle errors gracefully', async () => {\n      mockToolService.getToolsForApiKey.mockRejectedValue(new Error('Database error'));\n\n      await proxyHandler.handleChatCompletion(mockReq as any, mockRes as any);\n\n      expect(mockRes.status).toHaveBeenCalledWith(500);\n      expect(mockRes.json).toHaveBeenCalledWith({ error: 'Internal proxy error' });\n    });\n  });\n});"